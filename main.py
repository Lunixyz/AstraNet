import discord
import requests
import asyncio
import threading
import time
import os

intents = discord.Intents.default()
intents.message_content = True 

client = discord.Client(intents=intents)

#
#   ID do canal do Discord
#       Implementar um JSON com configura√ß√µes...
#

channel_id = 733465378360918066

#
#   Estado atual & √∫ltimo
#       Esses dois objetos guardam informa√ß√µes importantes para que o BOT n√£o repita o mesmo estado.
#       Ele lembrar√° do √∫ltimo estado de X servi√ßo e far√° uma compara√ß√£o para saber se o servi√ßo j√°
#       estava assim desde a √∫ltima verifica√ß√£o.
#

state = {}
last_state = {
    "sessions_logon": "unknown",
    "community": "unknown",
    "matchmaker": "unknown"
}

#   Dicion√°rios de convers√£o
#       Trocam palavras-chave para tradu√ß√µes
#       dicion√°rio["chave"] = "valor".

status_dictionary = { 
    "unknown": "Sem conex√£o com a API. ‚ùå",                   
    "normal": "Normal ‚úÖ", 
    "surge": "Falhando ‚ÅâÔ∏è", 
    "delayed": "Lento(a) üê¢", 
    "idle": "Inativo(a) üí§", 
    "offline": "Fora do ar ‚ùå" 
    }
capacity_dictionary = { 
    "unknown": "Sem conex√£o...", 
    "full": "Cheia", 
    "high": "Alta", 
    "medium": "M√©dia", 
    "low": "Baixa", 
    "offline": "Desligado" 
    }
load_dictionary = { 
    "unknown": "Sem conex√£o...", 
    "full": "Total", 
    "high": "Alta", 
    "medium": "M√©dia", 
    "low": "Limitada",  
    "idle": "Inativa" 
    }
api_status_dictionary = {
    200: "OK",
    400: "Bad Request",
    500: "Internal Server Error!!"
}

#   API de status
#       A cada 30 segundos, uma request para a Steam √© feita, retornando um JSON
#       Pegamos esse JSON e escolhemos valores espec√≠ficos (servi√ßos, criador de 
#       partidas...) Retornamos o status (caso n√£o seja "normal") em um canal 
#       espec√≠fico do Discord.
#

async def get_services():
    channel = client.get_channel(channel_id)
    embed = discord.Embed()


    if not channel:
        return
            
            #   Verifica√ß√µes
            #       Caso X servi√ßo n√£o esteja "normal" e n√£o seja igual ao mesmo 
            #       valor de antes, envie uma mensagem no canal Y.

    content = "# Status do Counter-Strike! :warning:"
    
    if state['sessions_logon'] != "normal" and last_state["sessions_logon"] != state['sessions_logon']:
        last_state["sessions_logon"] = state['sessions_logon']
        print(f"[Sessions] {state['sessions_logon']}")
        embed.title="Sess√µes"
        embed.description=f"A sess√£o de logon est√° `{status_dictionary[state['sessions_logon']]}`"
        embed.colour=discord.Color.red()
        return await channel.send(content=content, embed=embed)
               

    if state['community'] != "normal" and last_state["community"] != state['community']:
        last_state["community"] = state['community']
        print(f"[Community] {state['community']}")
        embed.title="Comunidade"
        embed.description=f"A comunidade est√° `{status_dictionary[state['community']]}`"
        embed.colour=discord.Color.red()
        return await channel.send(content=content, embed=embed)


    if state['matchmaker'] != "normal" and last_state["matchmaker"] != state['matchmaker']:
        last_state["matchmaker"] = state['matchmaker']
        print(f"[Matchmaker] {state['matchmaker']}")
        embed.title="Criador de partidas"
        embed.description=f"O criador de partidas est√° `{status_dictionary[state['matchmaker']]}`"
        embed.colour=discord.Color.red()
        return await channel.send(content=content, embed=embed)
    
    print(f"[Sessions] {state['sessions_logon']}")
    print(f"[Community] {state['community']}")
    print(f"[Matchmaker] {state['matchmaker']}")

async def embed_services(): 

    #
    #   Lista com atualiza√ß√µes dos servi√ßos
    #       Essa fun√ß√£o fica respons√°vel pela verifica√ß√£o e
    #       atualiza√ß√£o do objeto "state", que guarda o status
    #       de cada servi√ßo do Counter-Strike 2.
    #
        
    api = requests.get('https://ares.lunxi.dev/status')
    response = api.json()["data"]["status"]
    os.system('cls')
    print(f"[Ares API] {api_status_dictionary[api.status_code]}")


    last_state.update(state)
    state.clear()

    sessions_logon = response['services']['SessionsLogon']
    community = response['services']['SteamCommunity']
    matchmaker = response['matchmaker']['scheduler']

    state.update({ 
        "sessions_logon": sessions_logon, 
        "community": community, 
        "matchmaker": matchmaker, 
        })

def embed_function():
    embed = discord.Embed()
    embed.title = "Counter-Strike 2 ‚Äî Servi√ßos"
    embed.description =f"""
    Sess√µes: `{status_dictionary[state['sessions_logon']]}`
    Comunidade: `{status_dictionary[state['community']]}`
    Criador de partidas: `{status_dictionary[state['matchmaker']]}`
    \nPara invocar essa mensagem, digite `cs caiu` ou `>status`."""

    embed.color = discord.Color.blue()
    return embed

@client.event
async def on_reaction_add(reaction: discord.Reaction, user: discord.User):

    #
    #   Coleta de emojis
    #       Ap√≥s a rea√ß√£o do BOT ser adicionada na mensagem do usu√°rio,
    #       o BOT ir√° verificar se √© o emoji correto e se a rea√ß√£o foi
    #       do autor da mensagem. Ap√≥s isso, ele ir√° enviar uma embed
    #       com a lista dos status dos servi√ßos do Counter-Strike 2.
    #

    if user != reaction.message.author:
        return

    if reaction.emoji != "‚ùì":
        return
    
    embed = embed_function()

    await reaction.message.reply(embed=embed)
    await reaction.remove(client.user)
    await reaction.remove(user)

@client.event
async def on_message(message: discord.Message):
    if message.author.bot:
        return
    
    if message.content.lower().startswith("cs caiu"):
        await message.add_reaction("‚ùì")
    
    if message.content.lower().startswith(">status"):
        embed = embed_function()
        await message.reply(embed=embed)
#
#   Threading...
#       Utilizando uma fun√ß√£o de Threading, podemos rodar fun√ß√µes c√≠clicas ou loops
#       que n√£o bloqueiam o c√≥digo principal de funcionar, permitido o funcionamento
#       de todo c√≥digo sem esperar.

async def thread():
    starttime = time.time()
    while True:
        await embed_services()
        await get_services()
        time.sleep(5 - ((time.time() - starttime) % 5))

#
#   Inicializa√ß√£o
#       Ap√≥s o BOT inicializar, logo chamamos o asyncio para criar uma tarefa ass√≠ncrona
#       Essa tarefa ass√≠ncrona segura a fun√ß√£o de obten√ß√£o de dados da API, a cada 30 
#       segundos essa tarefa √© cumprida.

@client.event
async def on_ready():
    print(f"Logged in as {client.user}")
    threading.Thread(target=lambda: asyncio.run(thread())).start()


